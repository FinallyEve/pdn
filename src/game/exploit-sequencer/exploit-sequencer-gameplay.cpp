#include "game/exploit-sequencer/exploit-sequencer-states.hpp"
#include "game/exploit-sequencer/exploit-sequencer.hpp"
#include "game/exploit-sequencer/exploit-sequencer-resources.hpp"
#include "device/drivers/logger.hpp"
#include <string>

static const char* TAG = "ExploitSeqGameplay";

ExploitSequencerGameplay::ExploitSequencerGameplay(ExploitSequencer* game) : State(EXPLOIT_GAMEPLAY) {
    this->game = game;
}

ExploitSequencerGameplay::~ExploitSequencerGameplay() {
    game = nullptr;
}

void ExploitSequencerGameplay::onStateMounted(Device* PDN) {
    transitionToEvaluateState = false;

    auto& config = game->getConfig();

    LOG_I(TAG, "Gameplay — scroll speed %dms, marker at %d, window +/-%d",
        config.scrollSpeedMs, config.markerPosition, config.timingWindow);

    // Register PRIMARY button callback for exploit press
    parameterizedCallbackFunction pressCallback = [](void* ctx) {
        auto* state = static_cast<ExploitSequencerGameplay*>(ctx);
        auto& sess = state->game->getSession();
        if (!sess.playerPressed) {
            sess.playerPressed = true;
        }
    };
    PDN->getPrimaryButton()->setButtonPress(pressCallback, this, ButtonInteraction::CLICK);

    // Chase LED animation during gameplay
    AnimationConfig animConfig;
    animConfig.type = AnimationType::VERTICAL_CHASE;
    animConfig.speed = 8;
    animConfig.curve = EaseCurve::LINEAR;
    animConfig.initialState = EXPLOIT_SEQ_GAMEPLAY_STATE;
    animConfig.loopDelayMs = 200;
    animConfig.loop = true;
    PDN->getLightManager()->startAnimation(animConfig);

    // Display initial state
    PDN->getDisplay()->invalidateScreen();
    PDN->getDisplay()->setGlyphMode(FontMode::TEXT)
        ->drawText(">> INJECT <<", 15, 20)
        ->drawText("Press NOW!", 25, 45);
    PDN->getDisplay()->render();

    // Start the scroll timer
    scrollTimer.setTimer(config.scrollSpeedMs);
}

void ExploitSequencerGameplay::onStateLoop(Device* PDN) {
    auto& session = game->getSession();
    auto& config = game->getConfig();

    // Check for cable disconnect — forfeit if disconnected
    if (!PDN->isSerialConnected()) {
        LOG_W(TAG, "Cable disconnected during gameplay - forfeiting game");
        MiniGameOutcome outcome;
        outcome.result = MiniGameResult::LOST;
        outcome.score = session.score;
        outcome.hardMode = false;
        game->setOutcome(outcome);
        if (config.managedMode) {
            PDN->returnToPreviousApp();
        }
        return;
    }

    // If player pressed, transition to evaluate
    if (session.playerPressed) {
        transitionToEvaluateState = true;
        return;
    }

    // If symbol has scrolled past the end, timeout — transition to evaluate
    if (session.symbolPosition >= config.scrollLength) {
        transitionToEvaluateState = true;
        return;
    }

    // Advance symbol position on timer
    if (scrollTimer.expired()) {
        session.symbolPosition++;
        scrollTimer.setTimer(config.scrollSpeedMs);
    }
}

void ExploitSequencerGameplay::onStateDismounted(Device* PDN) {
    scrollTimer.invalidate();
    transitionToEvaluateState = false;
    PDN->getPrimaryButton()->removeButtonCallbacks();
}

bool ExploitSequencerGameplay::transitionToEvaluate() {
    return transitionToEvaluateState;
}
